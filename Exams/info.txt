2021.02.17
es1 --> analisi directory entry per capire se entry è un link simbolico, lettura link ed eventuale rimozione, lavoro con snprintf per preparare i path 
es2 --> analisi directory entry per capire se entry è un link simbolico, lettura link ed eventuale rimozione, lavoro con snprintf per preparare i path
creazione hard link, con ulteriore lavoro con snprintf per preparare i path + "accorciamento stringa" (inserendo '\0' prima)
es3 --> lettura file, controllo eseguibile, list.sort con lambda, os.path.getmtime(path) per sapere ultima modifica 

2022.07.22 
es2 --> realizzazione grafica del fs di una directory senza concatenare stringhe --> openat, fdopendir, dirent per 
vedere le varie entry della directory in esame, controllo se entry è directory o meno
es3 --> esecuzione di script, ma solo script non ELF (subprocess.run(script_path)) 

2023.07.20
-C --> copia fs in C, copia di file e utilizzo di hard link, uso di stat per vedere ultima modifica
-script python --> controllo caratteri ascii, subprocess con ls

2024.02.14
-C --> navigazione fs ricorsiva, uso di access per vedere se file è eseguibile o no, controllo se è bash(#!), o se è ELF (elf magic work)
-C --> simile  asopra, solo che quando trovo un eseguibile con il nome giusto lo esegue con i suoi parametri (execvp e fork), e lo eseguo nella sua directory corrente (chdir)
non funziona l'ordine di esecuzione dall'alto al basso del fs
-pyhton --> subprocess con file, dizionari, os per ottenere directory e file della current directory
-bash --> array associativi

2023.01.19
-es1, es2 --> pipe, execvp per esecuzione, dup2 per redirezione i/o fra le pipes, fgets per lettura stdin, strtok per tokenizzare 
una stringa dato un carattere separatore.
-es3 --> esplorazione ric. fs, creazione directory, copia file, append file

2023.09.14
-es1, es2 allocazione dinamica con malloc di un array dis tringeh char**, controllo tipo directory entry
-es3 lettura symlink + visita del fs

2023.05.31
-es1 --> lettura cartella /proc/PID con analisi dei file per leggere i contenuti di cmdline confrontarlo 
con la stringa in input --> utilizzo di memcmp 
-es2 --> non fatto, uguale a es2 20240530
-es3 --> dizionari, lettura link simbolici e lettura inode con os.Stat

2023.06.14
- es1 --> utilizzo timer con epoll --> epoll_event, epoll_create1, timerfd_create, timerfd_settime, epoll_ctl 
- es2 --> utilizzo timer multipli insieme con epoll, gestione argv e argc senza creare array aggiuntivi
- es3 --> NON FATTO 

2023.01.23
- es1 --> named pipe --> open read (se ritorna 0 altro estremo chiuso),
- es2 --> come sopra + invio di segnali con kill e ricezione custon nella prova
- es3 --> copia di file, scansione di directory e filtraggio directory

2024.01.19
- es1 --> concatenzione di stringhe con terminatore di stringa, da cui ricavare array di stringhe per excecvp
- es2 --> named pipe che riceve la stringa di comandi come formattata sopra, ricavare array di stringhe per excecvp ed esecuzione
- es3 --> lavoro con path e visita fs, operazioni con set, uso di sys.argv, uso di operazioni split e join

2024.05.30
-es1, es2 --> execvp e execvpe, con clonazione di un processo leggendo le sue info da proc/PID/cmdline e proc/PID/exe 
-es3 --> utilizzo di psutil per raccogliere i processi in base a pid e path dell'eseguibile, dizionari

2024.06.25
es1 --> inotify con aggiunta di file a una directory, parsing di stringhe per execv, fork 
es2 --> qualche problema...
es3 --> dizionari, subprocess con ls -l, symlink, mkdir
